# Office Word MCP Server 项目原则和约定

## 文档索引

- [1. 项目架构原则](#1-项目架构原则)
  - [1.1 分层架构](#11-分层架构)
  - [1.2 奥卡姆剃刀原则](#12-奥卡姆剃刀原则)
  - [1.3 扩展性设计](#13-扩展性设计)
  - [1.4 数据流程](#14-数据流程)
- [2. 工具开发规范](#2-工具开发规范)
  - [2.1 工具命名规范](#21-工具命名规范)
  - [2.2 工具实现模式](#22-工具实现模式)
  - [2.3 参数验证](#23-参数验证)
- [3. COM操作最佳实践](#3-com操作最佳实践)
  - [3.1 资源管理](#31-资源管理)
  - [3.2 错误处理](#32-错误处理)
  - [3.3 性能优化](#33-性能优化)
- [4. 代码风格与约定](#4-代码风格与约定)
  - [4.1 Python代码规范](#41-python代码规范)
  - [4.2 文件结构](#42-文件结构)
  - [4.3 命名约定](#43-命名约定)
- [5. 错误处理策略](#5-错误处理策略)
  - [5.1 分层错误处理](#51-分层错误处理)
  - [5.2 错误信息标准化](#52-错误信息标准化)
  - [5.3 日志记录](#53-日志记录)
- [6.jiang](#6-测试与质量保证)
  - [6.1 测试策略](#61-测试策略)
  - [6.2 自动化测试](#62-自动化测试)
  - [6.3 代码质量工具](#63-代码质量工具)
- [7. 文档与注释](#7-文档与注释)
  - [7.1 架构文档](#71-架构文档)
  - [7.2 API文档](#72-api文档)
  - [7.3 变更日志](#73-变更日志)
- [8. 部署与配置](#8-部署与配置)
  - [8.1 配置管理](#81-配置管理)
  - [8.2 多传输支持](#82-多传输支持)
  - [8.3 依赖管理](#83-依赖管理)
- [9. 安全与权限](#9-安全与权限)
  - [9.1 权限管理](#91-权限管理)
  - [9.2 数据安全](#92-数据安全)
  - [9.3 安全编码实践](#93-安全编码实践)
- [10. MCP服务器特有约定](#10-mcp服务器特有约定)
  - [10.1 工具定义规范](#101-工具定义规范)
  - [10.2 AppContext管理](#102-appcontext管理)
  - [10.3 选择器引擎使用](#103-选择器引擎使用)
- [11. 项目配置规则](#11-项目配置规则)
  - [11.1 框架版本](#111-框架版本)
  - [11.2 依赖管理](#112-依赖管理)
  - [11.3 过时API避免](#113-过时api避免)
  - [11.4 测试框架](#114-测试框架)
  - [11.5 代码质量工具](#115-代码质量工具)
- [12. 文件命名和重构规则](#12-文件命名和重构规则)
  - [12.1 文件命名规范](#121-文件命名规范)
  - [12.2 重构原则](#122-重构原则)
  - [12.3 模块合并](#123-模块合并)
- [13. 参考文档](#13-参考文档)
  - [13.1 MCP SDK 参考](#131-mcp-sdk-参考)
  - [13.2 Word COM 操作参考](#132-word-com-操作参考)
  - [13.3 开发参考资源](#133-开发参考资源)
- [14. 查找和定位规则](#14-查找和定位规则)
  - [14.1 查找函数返回值](#141-查找函数返回值)
  - [14.2 定位器辅助信息](#142-定位器辅助信息)
- [15. 动态定位器原则](#15-动态定位器原则)
  - [15.1 定位器稳定性](#151-定位器稳定性)
  - [15.2 动态更新机制](#152-动态更新机制)

## 1. 项目架构原则

### 1.1 分层架构
- 采用五组件分层架构：MCP服务层、选择器引擎、选择集抽象、操作层、COM后端
- 遵循"关注点分离"原则，各组件职责明确，耦合度低
- 保持组件间通信通过明确定义的接口进行
- 工具类通过`BaseWordTool`基类继承，共享通用功能

### 1.2 奥卡姆剃刀原则
- 系统设计保持简洁，避免不必要的复杂性，优先选择简单方案而非复杂方案
- 功能实现以满足需求为度，不追求过度设计
- 架构设计强调简洁性（simplicity over completeness）和实用性（pragmatism）

### 1.3 扩展性设计
- 预留扩展点，支持未来功能增强
- 遵循开闭原则，对扩展开放，对修改封闭
- 操作层模块设计支持插件化扩展
- 系统支持以下扩展方式：新增操作（在操作层添加新功能模块）、新增工具（在MCP服务层定义新工具接口）、增强选择器（扩展选择器引擎支持更多元素类型和过滤器）

### 1.4 数据流程
1. **工具调用** - AI客户端通过MCP协议调用特定工具
2. **上下文管理** - MCP服务层解析请求并管理会话上下文
3. **元素选择** - 选择器引擎根据定位器查找文档元素
4. **操作执行** - 选择集抽象调用操作层执行具体操作
5. **COM交互** - 操作层通过COM后端与Word应用程序交互
6. **结果返回** - 操作结果逐层返回给AI客户端

## 2. 工具开发规范

### 2.1 工具命名规范
- 工具类命名遵循`ToolName`格式，如`CommentTool`, `DocumentTool`
- 工具函数命名使用描述性名称，如`add_comment`, `get_document_styles`
- 避免命名冲突，操作层功能采用`op_`前缀或类似约定

### 2.2 工具实现模式
- 工具类继承自`BaseWordTool`以获取通用功能
- 使用装饰器进行错误处理、文档验证等横切关注点
- 工具接口保持统一风格，便于用户学习和使用

### 2.3 参数验证
- 严格验证输入参数的合法性
- 使用`require_active_document_validation`等验证工具
- 对关键参数进行类型检查和边界值验证

## 3. COM操作最佳实践

### 3.1 资源管理
- 所有COM操作必须使用`contextlib.contextmanager`或类似机制管理资源
- 使用`word_backend.py`中定义的上下文管理器处理Word实例
- 确保在异常情况下也能正确释放COM资源
- 遵循`connect`/`disconnect`模式管理Word应用程序生命周期
- 操作层模块设计遵循四项原则：一致性（consistency）、可维护性（maintainability）、错误处理（error handling）、可测试性（testability）

### 3.2 错误处理
- 使用`@handle_com_error`装饰器包装所有COM相关操作，统一错误处理方式
- 采用`safe_com_call`上下文管理器进行安全的COM调用
- 统一异常处理机制，将COM错误转换为`WordDocumentError`
- 使用`ErrorCode`枚举定义标准化的错误代码，覆盖通用错误、文档错误、元素错误、样式错误、格式化错误、图片错误、表格错误、注释错误等
- 实现分层错误处理机制：底层COM错误转换为应用级异常，工具层捕获并格式化错误信息，MCP服务层统一返回错误响应格式
- 使用`standardize_tool_errors`装饰器为工具函数提供标准化的错误处理

### 3.3 性能优化
- 重用已有的Word实例，避免频繁创建和销毁
- 优化选择器引擎，使用缓存提高元素查找效率
- 批量处理操作以减少COM调用次数

## 4. 代码风格与约定

### 4.1 Python代码规范
- 遵循PEP 8编码规范
- 类型注解：为所有函数添加完整的类型注解，包括参数类型和返回值类型
- 文档字符串：统一所有函数的文档字符串格式，确保每个函数都有清晰的描述、参数说明和返回值说明
- 使用`mypy`进行静态类型检查
- 代码质量工具：使用Black进行代码格式化，isort管理导入顺序，flake8检查代码风格
- **文件行限制**：单个代码文件不应超过500行，对于内容较多的文件，应按照功能逻辑拆分为多个小文件

### 4.2 文件结构
- 工具类直接放在`tools`目录下，按功能分类：
  - `document_ops.py`: 处理所有文档级操作
  - `text_content_ops.py`: 处理所有文本内容相关操作
  - `text_format_ops.py`: 处理所有文本格式化操作
  - `table_ops.py`: 处理所有表格相关操作
  - `image_ops.py`: 处理所有图片相关操作
  - `comment_ops.py`: 处理所有注释相关操作
  - `selector_ops.py`: 处理元素选择相关操作
  - `base_tool.py`: 工具基类和通用功能
  - `batch_operations.py`: 批量操作相关功能
- 核心操作逻辑封装在`operations`目录，按功能领域划分模块：
  - `__init__.py`: 导出操作模块的公共接口
  - `bookmark_ops.py`: 处理所有书签相关操作
  - `citations_ops.py`: 处理所有引用相关操作
  - `comment_ops.py`: 处理所有注释相关操作
  - `document_ops.py`: 处理所有文档级操作
  - `general_element_ops.py`: 处理通用元素选择和操作
  - `hyperlinks_ops.py`: 处理所有超链接相关操作
  - `image_ops.py`: 处理所有图片相关操作
  - `others_ops.py`: 处理其他杂项操作
  - `paragraphs_ops.py`: 处理所有段落相关操作
  - `styles_ops.py`: 处理所有样式相关操作
  - `table_ops.py`: 处理所有表格相关操作
  - `text_ops.py`: 处理所有文本相关操作
- COM后端实现位于`com_backend`目录
- 选择器相关功能在`selector`目录
- 通用工具函数放置于`utils`目录

### 4.3 命名约定
- 类名：使用PascalCase（`WordBackend`, `SelectorEngine`）
- 函数和变量：使用snake_case（`open_document`, `active_document`）
- 常量：使用全大写字母加下划线（`MAX_RETRY_COUNT`）
- 私有成员：前缀下划线（`_temp_word_app`）

## 5. 错误处理策略

### 5.1 分层错误处理
- **COM层**: 捕获并转换COM接口错误
- **操作层**: 统一处理操作相关错误，使用`@handle_com_error`装饰器
- **工具层**: 提供用户友好的错误信息，使用`standardize_tool_errors`装饰器
- **MCP层**: 按照MCP协议格式化错误响应，使用`format_error_response`函数

### 5.2 错误信息标准化
- 使用`format_error_response`函数统一错误响应格式
- 错误消息包含错误码、错误类型和详细描述
- 对用户友好的错误提示，避免暴露底层实现细节
- 对于常见错误类型提供具体的解决方案建议，如样式未找到时提供相似样式建议，无活动文档时提示先使用`open_document`

### 5.3 日志记录
- 使用标准日志记录模块(`logging`)替代`print`语句进行日志记录
- 关键操作和错误情况进行详细日志记录
- 异常发生时记录完整的堆栈信息，使用`exc_info=True`
- 日志级别根据错误严重程度设置
- 配置日志格式包含时间戳、日志名称、级别和消息内容
- 同时输出日志到文件和控制台

## 6. 测试与质量保证

### 6.1 测试策略
- 单元测试覆盖核心功能和边缘情况
- 集成测试验证组件间交互
- 端到端测试模拟实际使用场景
- 测试文档存放在`tests/test_docs`目录

### 6.2 自动化测试
- 使用标准测试框架编写可自动化测试
- 测试文件命名遵循`test_*.py`格式
- 测试应包括正常路径和异常路径

### 6.3 代码质量工具
- 使用`mypy`进行静态类型检查
- 使用`Black`进行代码格式化
- 使用`isort`管理导入顺序
- 定期运行测试套件确保功能正常
- 保持代码库整洁，移除重复代码和未使用的导入
- 统一函数参数顺序，特别是将文档对象作为第一个参数

## 7. 文档与注释

### 7.1 架构文档
- 维护`docs/Architecture.md`详细说明系统设计
- 记录架构决策和设计理由
- 文档应反映当前代码实现

### 7.2 API文档
- 为所有公共API提供详细文档字符串
- 文档包含参数说明、返回值、异常情况
- 提供使用示例帮助用户理解

### 7.3 变更日志
- 维护`docs/CHANGES.md`记录版本变更
- 记录新功能、修复的问题和不兼容变更
- 按时间倒序排列版本更新

## 8. 部署与配置

### 8.1 配置管理
- 使用`.env`文件管理环境变量
- 提供`.env.example`作为配置模板
- MCP配置通过`mcp-config.json`管理

### 8.2 多传输支持
- 支持streamable-http、sse和stdio多种传输方式
- 配置适配不同的部署环境
- 提供测试命令验证配置正确性

### 8.3 依赖管理
- 使用`requirements.txt`或`pyproject.toml`管理依赖
- 明确指定依赖版本，确保环境一致性
- 使用虚拟环境隔离项目依赖

## 9. 安全与权限

### 9.1 权限管理
- 限制对敏感操作的访问权限
- 验证用户请求的合法性
- 防止恶意操作和滥用

### 9.2 数据安全
- 保护用户文档数据安全
- 处理敏感信息时注意加密和保护
- 避免泄露用户文档内容

### 9.3 安全编码实践
- 避免常见的安全漏洞
- 输入验证和输出编码
- 防止注入攻击和路径遍历

## 10. MCP服务器特有约定

### 10.1 工具定义规范
- 工具定义遵循MCP服务器规范
- 输入参数和返回值格式保持一致
- 工具名称和描述清晰明确

### 10.2 AppContext管理
- 正确使用AppContext管理应用程序生命周期
- 避免上下文泄漏和资源浪费
- 遵循context manager模式处理资源

### 10.3 选择器引擎使用
- 统一使用SelectorEngine进行元素定位
- 遵循定位器语法规范（"type:value[filters]"）
- 优化选择器性能，合理使用缓存

## 11. 项目配置规则

### 11.1 框架版本
- **Python版本**：>=3.11
- **项目版本**：1.1.9
- **MCP版本**：>=1.1.0

### 11.2 依赖管理

#### 11.2.1 核心依赖
- mcp[cli]>=1.1.0
- pywin32>=306
- msoffcrypto-tool>=5.4.2

#### 11.2.2 开发依赖
- pytest>=7.0
- pytest-asyncio>=0.21
- black>=23.0
- isort>=5.0
- mypy>=1.0

#### 11.2.3 依赖管理工具
- 使用pyproject.toml管理项目依赖和元数据
- 使用requirements.txt补充额外依赖
- 开发环境应使用虚拟环境隔离依赖

### 11.3 过时API避免
- 避免使用手工try/except块处理COM错误，应使用统一的`@handle_com_error`装饰器
- 避免使用print语句进行日志记录，应使用标准的logging模块
- 避免使用不一致的文档字符串格式，应遵循项目统一的文档字符串规范
- 避免使用不完整的类型注解，应为所有函数添加完整的类型注解

### 11.4 测试框架

#### 11.4.1 测试工具
- **测试框架**：使用unittest作为主要测试框架
- **测试运行器**：使用pytest运行测试
- **测试文件位置**：所有测试文件位于`tests`目录下，命名遵循`test_*.py`格式

#### 11.4.2 测试类型
- **单元测试**：测试单个函数或类的功能
- **集成测试**：测试多个组件之间的交互
- **端到端测试**：模拟实际使用场景测试完整流程
- **测试文档**：测试用文档存放于`tests/test_docs`目录

### 11.5 代码质量工具

#### 11.5.1 静态分析工具
- **mypy**：进行静态类型检查，配置见mypy.ini
- **black**：代码格式化，确保代码风格一致
- **isort**：管理导入顺序，保持代码整洁

#### 11.5.2 质量检查命令
```
# 格式化代码
black word_document_server

# 排序导入
isort word_document_server

# 静态类型检查
mypy word_document_server
```

#### 11.5.3 配置文件
- **mypy.ini**：配置静态类型检查规则
- **pyproject.toml**：配置项目元数据、依赖和构建选项
- **.env**：环境变量配置
- **.env.example**：配置模板示例

## 12. 文件命名和重构规则

确保项目结构清晰、易于维护，特制定以下文件命名和重构规则。

### 12.1 文件命名规范

1. **描述性命名**：文件名应清楚地描述文件内容和用途
   - ✅ 正确示例：`general_element_ops.py`、`comment_integration_tool.py`
   - ❌ 错误示例：`common_ops.py`、`utils.py`

2. **功能导向命名**：文件名应体现其主要功能领域
   - 对于操作类文件，使用 `功能领域_ops.py` 或 `功能领域_operations.py` 格式
   - 对于工具类文件，使用 `功能领域_tools.py` 或 `功能领域_tool.py` 格式

3. **避免缩写**：除非是广泛认知的缩写，否则应使用完整单词

4. **一致性**：同类型文件应保持命名风格一致

### 12.2 重构原则

1. **渐进式重构**：重构应逐步进行，避免大规模一次性修改

2. **保持功能一致**：重构过程中应确保功能不变，仅改善代码结构

3. **更新引用**：重命名或移动文件时，必须更新所有相关引用

4. **测试覆盖**：重构前后应确保测试通过，必要时更新测试用例

### 12.3 模块合并

1. **功能相关性**：只有功能紧密相关的模块才应考虑合并

2. **避免重复**：合并模块时应消除重复代码和功能

3. **职责单一**：合并后的模块应保持职责清晰，避免过于臃肿

4. **接口兼容**：模块合并时应保持对外接口的兼容性，或提供适当的适配层

## 13. 参考文档

### 13.1 MCP SDK 参考

#### 13.1.1 MCP 核心概念
- **工具(Tool)**: MCP 服务提供的功能单元，通过 `@mcp_server.tool()` 装饰器定义
- **上下文(Context)**: 包含会话状态和应用程序上下文，使用 `Context[ServerSession, AppContext]` 类型
- **请求处理**: 工具函数接收参数并返回结果，遵循 MCP 协议格式
- **会话管理**: 通过 `ServerSession` 维护会话状态，支持多用户并发

#### 13.1.2 常用 MCP 装饰器
```
# 定义工具函数
def my_tool(ctx: Context[ServerSession, AppContext], param1: str, ...) -> str:
    # 工具实现
    return "结果"

# 工具定义与装饰器示例
@mcp_server.tool()          # 定义工具函数
@handle_tool_errors         # 添加错误处理装饰器
@require_active_document_validation  # 添加文档验证装饰器
```

#### 13.1.3 Context 使用示例
```
# 获取活动文档
active_doc = ctx.request_context.lifespan_context.get_active_document()

# 记录日志
ctx.info("操作信息")
ctx.error("错误信息")

# 获取应用程序上下文
app_context = ctx.request_context.lifespan_context
```

#### 13.1.4 MCP 配置文件
- **mcp-config.json**: 定义 MCP 服务器配置，包括传输方式、端口、日志级别等
- **配置示例**: 支持 streamable-http、sse 和 stdio 多种传输方式

### 13.2 Word COM 操作参考

#### 13.2.1 Word COM 对象模型
- **Application**: Word 应用程序实例，通过 `win32com.client.Dispatch('Word.Application')` 创建
- **Document**: 文档对象，通过 `word_app.Documents.Open(file_path)` 获取
- **Selection**: 选区对象，通过 `word_app.Selection` 获取
- **Paragraphs**: 段落集合，通过 `document.Paragraphs` 获取
- **Tables**: 表格集合，通过 `document.Tables` 获取
- **Comments**: 注释集合，通过 `document.Comments` 获取
- **InlineShapes**: 嵌入图形集合，通过 `document.InlineShapes` 获取

#### 13.2.2 常用 COM 操作示例

##### 13.2.2.1 文档操作
```
# 创建 Word 应用实例
word_app = win32com.client.Dispatch('Word.Application')
word_app.Visible = True

# 打开文档
doc = word_app.Documents.Open(file_path)

# 保存文档
doc.Save()

# 关闭文档
doc.Close(SaveChanges=True)

# 退出 Word 应用
word_app.Quit()
```

##### 13.2.2.2 段落操作
```
# 获取所有段落
paragraphs = doc.Paragraphs

# 遍历段落
for i in range(1, paragraphs.Count + 1):
    paragraph = paragraphs(i)
    text = paragraph.Range.Text
    print(f"段落 {i}: {text}")

# 插入新段落
new_range = doc.Content
new_range.Collapse(Direction=0)  # wdCollapseStart
new_range.Text = "新段落内容\n"
```

##### 13.2.2.3 文本查找和替换
```
# 创建查找对象
find = doc.Content.Find
find.Text = "查找文本"
find.Replacement.Text = "替换文本"
find.MatchCase = False
find.MatchWholeWord = True

# 执行替换
find.Execute(Replace=2)  # wdReplaceAll
```

##### 13.2.2.4 表格操作
```
# 获取所有表格
tables = doc.Tables

# 遍历表格
for table_idx in range(1, tables.Count + 1):
    table = tables(table_idx)
    # 访问单元格
    cell = table.Cell(Row=1, Column=1)
    cell_text = cell.Range.Text
    # 设置单元格内容
    cell.Range.Text = "新内容"
```

##### 13.2.2.5 样式操作
```
# 获取所有样式
styles = doc.Styles

# 应用样式到段落
paragraph = doc.Paragraphs(1)
paragraph.Style = "Heading 1"

# 设置字体
font = paragraph.Range.Font
font.Name = "Arial"
font.Size = 12
font.Bold = True

# 设置段落格式
format = paragraph.Format
format.Alignment = 1  # wdAlignParagraphCenter
format.SpaceAfter = 12
```

#### 13.2.3 COM 错误处理最佳实践
- 使用 `@handle_com_error` 装饰器统一处理 COM 异常
- 使用 `safe_com_call` 上下文管理器进行安全的 COM 调用
- 遵循资源管理最佳实践，确保 COM 对象正确释放
- 捕获特定的 COM 错误代码，并提供有针对性的错误信息
- 使用 `win32com.client.constants` 访问 Word 常量值

### 13.3 开发参考资源

#### 13.3.1 官方文档
- **MCP 协议文档**: https://modelcontextprotocol.io/
- **pywin32 文档**: https://github.com/mhammond/pywin32/wiki
- **Microsoft Word VBA 参考**: https://learn.microsoft.com/zh-cn/office/vba/api/overview/word

#### 13.3.2 项目文档
- **架构文档**: docs/Architecture.md
- **变更日志**: docs/CHANGES.md
- **任务文档**: docs/Task.md
- **Agent 指南**: docs/agent_guide.md

## 14. 查找和定位规则

确保AI能够有效利用查找结果构建新的定位参数，特制定以下查找和定位规则。

### 14.1 查找函数返回值

1. **丰富的上下文信息**：查找函数应返回足够的上下文信息，包括但不限于：
   - 匹配文本的位置信息（起始和结束位置）
   - 匹配文本所在的段落信息
   - 匹配文本周围的环境信息

2. **定位器辅助数据**：查找函数应提供可以直接用于构建新定位器的数据结构，包括：
   - 范围定位器：基于字符位置的精确定位器
   - 段落定位器：基于段落索引的相对定位器
   - 文本定位器：基于文本内容的语义定位器

3. **可重用的定位参数**：返回的数据应包含可以直接在后续操作中重用的定位参数

### 14.2 定位器辅助信息

1. **多维度定位支持**：定位器应支持多种定位方式的组合，包括：
   - 绝对定位（基于字符位置）
   - 相对定位（基于元素索引）
   - 语义定位（基于文本内容或样式）

2. **辅助构建机制**：系统应提供辅助机制帮助AI构建复杂的定位器，包括：
   - 定位器模板
   - 定位器组合工具
   - 定位器验证功能

## 15. 动态定位器原则

为确保在文档修改操作中定位器的稳定性和可靠性，特制定动态定位器原则。

### 15.1 定位器稳定性

1. **相对定位优于绝对定位**：在可能的情况下，应优先使用基于内容特征的相对定位，而不是依赖绝对索引或位置坐标。

2. **内容特征定位**：应基于元素的文本内容、样式等不易受其他修改影响的特征进行定位，避免使用易变的位置信息。

3. **避免长时间持有定位器引用**：定位器应在使用后立即执行操作，避免跨多个操作步骤使用同一定位器。

### 15.2 动态更新机制

1. **先查找后操作模式**：在执行修改操作前先使用定位器查找元素，获取元素的实时位置信息，然后基于这些信息执行操作。

2. **批量操作策略**：将相关的操作分组执行，减少定位器失效的影响。

3. **错误恢复机制**：在定位器失效时，应提供适当的错误恢复机制，如重新查找或使用备选定位策略。
